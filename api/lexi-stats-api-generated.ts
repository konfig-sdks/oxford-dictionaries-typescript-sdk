/* tslint:disable */
/* eslint-disable */
/*
Oxford Dictionaries

Oxford Dictionaries, part of the Oxford Language Division, is a leading authority on the English language. It offers a wide range of language resources, including dictionaries, thesauruses, grammar guides, and language learning tools. Oxford Dictionaries provides accurate and up-to-date definitions, word origins, and usage examples to support language comprehension and communication.

The version of the OpenAPI document: 1.11.0


NOTE: This file is auto generated by Konfig (https://konfigthis.com).
*/

import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction, isBrowser } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { NgramsResult } from '../models';
// @ts-ignore
import { StatsWordResult } from '../models';
// @ts-ignore
import { StatsWordResultList } from '../models';
import { paginate } from "../pagination/paginate";
import type * as buffer from "buffer"
import { requestBeforeHook } from '../requestBeforeHook';
/**
 * LexiStatsApi - axios parameter creator
 * @export
 */
export const LexiStatsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint returns frequencies of ngrams of size 1-4. That is the number of times a word (ngram size = 1) or words (ngram size > 1) appear in the corpus. Ngrams are case sensitive (\"I AM\" and \"I am\" will have different frequency) and frequencies are calculated per word (true case) so \"the book\" and \"the books\" are two different ngrams. The results can be filtered based on query parameters. <br> <br> Parameters can be provided in PATH, GET or POST (form or json). The parameters in PATH are overridden by parameters in GET, POST and json (in that order). In PATH, individual options are separated by semicolon and values are separated by commas (where multiple values can be used). <br> <br> Example for bigrams (ngram of size 2): * PATH: /tokens=a word,another word * GET: /?tokens=a word&tokens=another word * POST (json):    ```javascript     {         \"tokens\": [\"a word\", \"another word\"]     }   ```  Either \"tokens\" or \"contains\" has to be provided. <br> <br> Some queries with \"contains\" or \"sort\" can exceed the 30s timeout, in which case the API will return an error message with status code 503. You mitigate this by providing additional restrictions such as \"minFrequency\" and \"maxFrequency\". <br> <br> You can use the parameters \"offset\" and \"limit\" to paginate through large result sets. For convenience, the HTTP header \"Link\" is set on the response to provide links to \"first\", \"self\", \"next\", \"prev\" and \"last\" pages of results (depending on the context). For example, if the result set contains 50 results and the parameter \"limit\" is set to 25, the Links header will contain an URL for the first 25 results and the next 25 results. <br> <br> Some libraries such as python\'s `requests` can parse the header automatically and offer a convenient way of iterating through the results. For example: ```python def get_all_results(url):     while url:         r = requests.get(url)         r.raise_for_status()         for item in r.json()[\'results\']:           yield item         url = r.links.get(\'next\', {}).get(\'url\') ``` 
         * @summary Retrieve the frequency of ngrams (1-4) derived from a corpus
         * @param {string} sourceLang IANA language code
         * @param {string} corpus For corpora other than \&#39;nmc\&#39; (New Monitor Corpus) please contact api@oxforddictionaries.com
         * @param {string} ngramSize the size of ngrams requested (1-4)
         * @param {string} [tokens] List of tokens to filter. The tokens are separated by spaces, the list items are separated by comma (e.g., for bigrams (n&#x3D;2) tokens&#x3D;this is,this was, this will)
         * @param {string} [contains] Find ngrams containing the given token(s). Use comma or space as token separators; the order of tokens is irrelevant.
         * @param {string} [punctuation] Flag specifying whether to lookup ngrams that include punctuation or not (possible values are \&quot;true\&quot; and \&quot;false\&quot;; default is \&quot;false\&quot;)
         * @param {string} [format] Option specifying whether tokens should be returned as a single string (option \&quot;google\&quot;) or as a list of strings (option \&quot;oup\&quot;)
         * @param {number} [minFrequency] Restrict the query to entries with frequency of at least &#x60;minFrequency&#x60;
         * @param {number} [maxFrequency] Restrict the query to entries with frequency of at most &#x60;maxFrequency&#x60;
         * @param {number} [minDocumentFrequency] Restrict the query to entries that appear in at least &#x60;minDocumentFrequency&#x60; documents
         * @param {number} [maxDocumentFrequency] Restrict the query to entries that appera in at most &#x60;maxDocumentFrequency&#x60; documents
         * @param {string} [collate] collate the results by wordform, trueCase, lemma, lexicalCategory. Multiple values can be separated by commas (e.g., collate&#x3D;trueCase,lemma,lexicalCategory).
         * @param {string} [sort] sort the resulting list by wordform, trueCase, lemma, lexicalCategory, frequency, normalizedFrequency. Descending order is achieved by prepending the value with the minus sign (\&#39;-\&#39;). Multiple values can be separated by commas (e.g., sort&#x3D;lexicalCategory,-frequency)
         * @param {number} [offset] pagination - results offset
         * @param {number} [limit] pagination - results limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNgramFrequencies: async (sourceLang: string, corpus: string, ngramSize: string, tokens?: string, contains?: string, punctuation?: string, format?: string, minFrequency?: number, maxFrequency?: number, minDocumentFrequency?: number, maxDocumentFrequency?: number, collate?: string, sort?: string, offset?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceLang' is not null or undefined
            assertParamExists('getNgramFrequencies', 'sourceLang', sourceLang)
            // verify required parameter 'corpus' is not null or undefined
            assertParamExists('getNgramFrequencies', 'corpus', corpus)
            // verify required parameter 'ngramSize' is not null or undefined
            assertParamExists('getNgramFrequencies', 'ngramSize', ngramSize)
            const localVarPath = `/stats/frequency/ngrams/{source_lang}/{corpus}/{ngram-size}`
                .replace(`{${"source_lang"}}`, encodeURIComponent(String(sourceLang !== undefined ? sourceLang : `-source_lang-`)))
                .replace(`{${"corpus"}}`, encodeURIComponent(String(corpus !== undefined ? corpus : `-corpus-`)))
                .replace(`{${"ngram-size"}}`, encodeURIComponent(String(ngramSize !== undefined ? ngramSize : `-ngram-size-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication appId required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "app_id", keyParamName: "appId", configuration })
            // authentication appKey required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "app_key", keyParamName: "appKey", configuration })
            if (tokens !== undefined) {
                localVarQueryParameter['tokens'] = tokens;
            }

            if (contains !== undefined) {
                localVarQueryParameter['contains'] = contains;
            }

            if (punctuation !== undefined) {
                localVarQueryParameter['punctuation'] = punctuation;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            if (minFrequency !== undefined) {
                localVarQueryParameter['minFrequency'] = minFrequency;
            }

            if (maxFrequency !== undefined) {
                localVarQueryParameter['maxFrequency'] = maxFrequency;
            }

            if (minDocumentFrequency !== undefined) {
                localVarQueryParameter['minDocumentFrequency'] = minDocumentFrequency;
            }

            if (maxDocumentFrequency !== undefined) {
                localVarQueryParameter['maxDocumentFrequency'] = maxDocumentFrequency;
            }

            if (collate !== undefined) {
                localVarQueryParameter['collate'] = collate;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/stats/frequency/ngrams/{source_lang}/{corpus}/{ngram-size}',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint provides a list of frequencies for a given word or words. Unlike the /word/ endpoint, the results are split into the smallest units. <br> <br> To exclude a specific value, prepend it with the minus sign (\'-\'). For example, to get frequencies of the lemma \'happy\' but exclude superlative forms (i.e., happiest) you could use options \'lemma=happy;grammaticalFeatures=-degreeType:superlative\'. <br> <br> Parameters can be provided in PATH, GET or POST (form or json). The parameters in PATH are overridden by parameters in GET, POST and json (in that order). In PATH, individual options are separated by semicolon and values are separated by commas (where multiple values can be used). <br> <br> The parameters wordform/trueCase/lemma/lexicalCategory also exist in a plural form, taking a lists of items. Examples: * PATH: /wordforms=happy,happier,happiest * GET: /?wordforms=happy&wordforms=happier&wordforms=happiest * POST (json): ```javascript   {     \"wordforms\": [\"happy\", \"happier\", \"happiest\"]   } ``` A mor complex example of retrieving frequencies of multiple lemmas: ```   {       \"lemmas\": [\"happy\", \"content\", \"cheerful\", \"cheery\", \"merry\", \"joyful\", \"ecstatic\"],       \"grammaticalFeatures\": {           \"adjectiveFunctionType\": \"predicative\"       },       \"lexicalCategory\": \"adjective\",       \"sort\": [\"lemma\", \"-frequency\"]   } ``` Some queries with \"collate\" or \"sort\" can exceed the 30s timeout, in which case the API will return an error message with status code 503. You mitigate this by providing additional restrictions such as \"minFrequency\" and \"maxFrequency\". <br> <br> You can use the parameters \"offset\" and \"limit\" to paginate through large result sets. For convenience, the HTTP header \"Link\" is set on the response to provide links to \"first\", \"self\", \"next\", \"prev\" and \"last\" pages of results (depending on the context). For example, if the result set contains 50 results and the parameter \"limit\" is set to 25, the Links header will contain an URL for the first 25 results and the next 25 results. <br> <br> Some libraries such as python\'s `requests` can parse the header automatically and offer a convenient way of iterating through the results. For example: ```python def get_all_results(url):     while url:         r = requests.get(url)         r.raise_for_status()         for item in r.json()[\'results\']:           yield item         url = r.links.get(\'next\', {}).get(\'url\') ``` 
         * @summary Retrieve a list of frequencies of a word/words derived from a corpus.
         * @param {string} sourceLang IANA language code
         * @param {string} [corpus] For corpora other than \&#39;nmc\&#39; (New Monitor Corpus) please contact api@oxforddictionaries.com
         * @param {string} [wordform] The written form of the word to look up (preserving case e.g., Book vs book)
         * @param {string} [trueCase] The written form of the word to look up with normalised case (Books --&gt; books)
         * @param {string} [lemma] The lemma of the word to look up (e.g., Book, booked, books all have the lemma \&quot;book\&quot;)
         * @param {string} [lexicalCategory] The lexical category of the word(s) to look up (e.g., adjective or noun)
         * @param {string} [grammaticalFeatures] The grammatical features of the word(s) to look up entered as a list of k:v (e.g., degree_type:comparative)
         * @param {string} [sort] sort the resulting list by wordform, trueCase, lemma, lexicalCategory, frequency, normalizedFrequency. Descending order is achieved by prepending the value with the minus sign (\&#39;-\&#39;). Multiple values can be separated by commas (e.g., sort&#x3D;lexicalCategory,-frequency)
         * @param {string} [collate] collate the results by wordform, trueCase, lemma, lexicalCategory. Multiple values can be separated by commas (e.g., collate&#x3D;trueCase,lemma,lexicalCategory).
         * @param {number} [minFrequency] Restrict the query to entries with frequency of at least &#x60;minFrequency&#x60;
         * @param {number} [maxFrequency] Restrict the query to entries with frequency of at most &#x60;maxFrequency&#x60;
         * @param {number} [minNormalizedFrequency] Restrict the query to entries with frequency of at least &#x60;minNormalizedFrequency&#x60;
         * @param {number} [maxNormalizedFrequency] Restrict the query to entries with frequency of at most &#x60;maxNormalizedFrequency&#x60;
         * @param {number} [offset] pagination - results offset
         * @param {number} [limit] pagination - results limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWordFrequencies: async (sourceLang: string, corpus?: string, wordform?: string, trueCase?: string, lemma?: string, lexicalCategory?: string, grammaticalFeatures?: string, sort?: string, collate?: string, minFrequency?: number, maxFrequency?: number, minNormalizedFrequency?: number, maxNormalizedFrequency?: number, offset?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceLang' is not null or undefined
            assertParamExists('getWordFrequencies', 'sourceLang', sourceLang)
            const localVarPath = `/stats/frequency/words/{source_lang}`
                .replace(`{${"source_lang"}}`, encodeURIComponent(String(sourceLang !== undefined ? sourceLang : `-source_lang-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication appId required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "app_id", keyParamName: "appId", configuration })
            // authentication appKey required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "app_key", keyParamName: "appKey", configuration })
            if (corpus !== undefined) {
                localVarQueryParameter['corpus'] = corpus;
            }

            if (wordform !== undefined) {
                localVarQueryParameter['wordform'] = wordform;
            }

            if (trueCase !== undefined) {
                localVarQueryParameter['trueCase'] = trueCase;
            }

            if (lemma !== undefined) {
                localVarQueryParameter['lemma'] = lemma;
            }

            if (lexicalCategory !== undefined) {
                localVarQueryParameter['lexicalCategory'] = lexicalCategory;
            }

            if (grammaticalFeatures !== undefined) {
                localVarQueryParameter['grammaticalFeatures'] = grammaticalFeatures;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (collate !== undefined) {
                localVarQueryParameter['collate'] = collate;
            }

            if (minFrequency !== undefined) {
                localVarQueryParameter['minFrequency'] = minFrequency;
            }

            if (maxFrequency !== undefined) {
                localVarQueryParameter['maxFrequency'] = maxFrequency;
            }

            if (minNormalizedFrequency !== undefined) {
                localVarQueryParameter['minNormalizedFrequency'] = minNormalizedFrequency;
            }

            if (maxNormalizedFrequency !== undefined) {
                localVarQueryParameter['maxNormalizedFrequency'] = maxNormalizedFrequency;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/stats/frequency/words/{source_lang}',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint provides the frequency of a given word. When multiple database records match the query parameters, the returned frequency is the sum of the individual frequencies. For example, if the query parameters are lemma=test, the returned frequency will include the verb \"test\", the noun \"test\" and the adjective \"test\" in all forms (Test, tested, testing, etc.) <br> <br> If you are interested in the frequency of the word \"test\" but want to exclude other forms (e.g., tested) use the option trueCase=test. Normally, the word \"test\" will be spelt with a capital letter at the beginning of a sentence. The option trueCase will ignore this and it will count \"Test\" and \"test\" as the same token. If you are interested in frequencies of \"Test\" and \"test\", use the option wordform=test or wordform=Test. Note that trueCase is not just a lower case of the word as some words are genuinely spelt with a capital letter such as the word \"press\" in Oxford University Press. <br> <br> Parameters can be provided in PATH, GET or POST (form or json). The parameters in PATH are overriden by parameters in GET, POST and json (in that order). In PATH, individual options are separated by semicolon and values are separated by commas (where multiple values can be used). Examples: * PATH: /lemma=test;lexicalCategory=noun * GET: /?lemma=test&lexicalCategory=noun * POST (json):    ```javascript     {       \"lemma\": \"test\",       \"lexicalCategory\": \"noun\"     }   ```  <br> One of the options wordform/trueCase/lemma/lexicalCategory has to be provided. 
         * @summary Retrieve the frequency of a word derived from a corpus.
         * @param {string} sourceLang IANA language code
         * @param {string} [corpus] For corpora other than \&#39;nmc\&#39; (New Monitor Corpus) please contact api@oxforddictionaries.com
         * @param {string} [wordform] The written form of the word to look up (preserving case e.g., Books vs books)
         * @param {string} [trueCase] The written form of the word to look up with normalised case (Books --&gt; books)
         * @param {string} [lemma] The lemma of the word to look up (e.g., Book, booked, books all have the lemma \&quot;book\&quot;)
         * @param {string} [lexicalCategory] The lexical category of the word(s) to look up (e.g., noun or verb)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWordFrequency: async (sourceLang: string, corpus?: string, wordform?: string, trueCase?: string, lemma?: string, lexicalCategory?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceLang' is not null or undefined
            assertParamExists('getWordFrequency', 'sourceLang', sourceLang)
            const localVarPath = `/stats/frequency/word/{source_lang}`
                .replace(`{${"source_lang"}}`, encodeURIComponent(String(sourceLang !== undefined ? sourceLang : `-source_lang-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication appId required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "app_id", keyParamName: "appId", configuration })
            // authentication appKey required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "app_key", keyParamName: "appKey", configuration })
            if (corpus !== undefined) {
                localVarQueryParameter['corpus'] = corpus;
            }

            if (wordform !== undefined) {
                localVarQueryParameter['wordform'] = wordform;
            }

            if (trueCase !== undefined) {
                localVarQueryParameter['trueCase'] = trueCase;
            }

            if (lemma !== undefined) {
                localVarQueryParameter['lemma'] = lemma;
            }

            if (lexicalCategory !== undefined) {
                localVarQueryParameter['lexicalCategory'] = lexicalCategory;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/stats/frequency/word/{source_lang}',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LexiStatsApi - functional programming interface
 * @export
 */
export const LexiStatsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LexiStatsApiAxiosParamCreator(configuration)
    return {
        /**
         * This endpoint returns frequencies of ngrams of size 1-4. That is the number of times a word (ngram size = 1) or words (ngram size > 1) appear in the corpus. Ngrams are case sensitive (\"I AM\" and \"I am\" will have different frequency) and frequencies are calculated per word (true case) so \"the book\" and \"the books\" are two different ngrams. The results can be filtered based on query parameters. <br> <br> Parameters can be provided in PATH, GET or POST (form or json). The parameters in PATH are overridden by parameters in GET, POST and json (in that order). In PATH, individual options are separated by semicolon and values are separated by commas (where multiple values can be used). <br> <br> Example for bigrams (ngram of size 2): * PATH: /tokens=a word,another word * GET: /?tokens=a word&tokens=another word * POST (json):    ```javascript     {         \"tokens\": [\"a word\", \"another word\"]     }   ```  Either \"tokens\" or \"contains\" has to be provided. <br> <br> Some queries with \"contains\" or \"sort\" can exceed the 30s timeout, in which case the API will return an error message with status code 503. You mitigate this by providing additional restrictions such as \"minFrequency\" and \"maxFrequency\". <br> <br> You can use the parameters \"offset\" and \"limit\" to paginate through large result sets. For convenience, the HTTP header \"Link\" is set on the response to provide links to \"first\", \"self\", \"next\", \"prev\" and \"last\" pages of results (depending on the context). For example, if the result set contains 50 results and the parameter \"limit\" is set to 25, the Links header will contain an URL for the first 25 results and the next 25 results. <br> <br> Some libraries such as python\'s `requests` can parse the header automatically and offer a convenient way of iterating through the results. For example: ```python def get_all_results(url):     while url:         r = requests.get(url)         r.raise_for_status()         for item in r.json()[\'results\']:           yield item         url = r.links.get(\'next\', {}).get(\'url\') ``` 
         * @summary Retrieve the frequency of ngrams (1-4) derived from a corpus
         * @param {LexiStatsApiGetNgramFrequenciesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNgramFrequencies(requestParameters: LexiStatsApiGetNgramFrequenciesRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NgramsResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNgramFrequencies(requestParameters.sourceLang, requestParameters.corpus, requestParameters.ngramSize, requestParameters.tokens, requestParameters.contains, requestParameters.punctuation, requestParameters.format, requestParameters.minFrequency, requestParameters.maxFrequency, requestParameters.minDocumentFrequency, requestParameters.maxDocumentFrequency, requestParameters.collate, requestParameters.sort, requestParameters.offset, requestParameters.limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint provides a list of frequencies for a given word or words. Unlike the /word/ endpoint, the results are split into the smallest units. <br> <br> To exclude a specific value, prepend it with the minus sign (\'-\'). For example, to get frequencies of the lemma \'happy\' but exclude superlative forms (i.e., happiest) you could use options \'lemma=happy;grammaticalFeatures=-degreeType:superlative\'. <br> <br> Parameters can be provided in PATH, GET or POST (form or json). The parameters in PATH are overridden by parameters in GET, POST and json (in that order). In PATH, individual options are separated by semicolon and values are separated by commas (where multiple values can be used). <br> <br> The parameters wordform/trueCase/lemma/lexicalCategory also exist in a plural form, taking a lists of items. Examples: * PATH: /wordforms=happy,happier,happiest * GET: /?wordforms=happy&wordforms=happier&wordforms=happiest * POST (json): ```javascript   {     \"wordforms\": [\"happy\", \"happier\", \"happiest\"]   } ``` A mor complex example of retrieving frequencies of multiple lemmas: ```   {       \"lemmas\": [\"happy\", \"content\", \"cheerful\", \"cheery\", \"merry\", \"joyful\", \"ecstatic\"],       \"grammaticalFeatures\": {           \"adjectiveFunctionType\": \"predicative\"       },       \"lexicalCategory\": \"adjective\",       \"sort\": [\"lemma\", \"-frequency\"]   } ``` Some queries with \"collate\" or \"sort\" can exceed the 30s timeout, in which case the API will return an error message with status code 503. You mitigate this by providing additional restrictions such as \"minFrequency\" and \"maxFrequency\". <br> <br> You can use the parameters \"offset\" and \"limit\" to paginate through large result sets. For convenience, the HTTP header \"Link\" is set on the response to provide links to \"first\", \"self\", \"next\", \"prev\" and \"last\" pages of results (depending on the context). For example, if the result set contains 50 results and the parameter \"limit\" is set to 25, the Links header will contain an URL for the first 25 results and the next 25 results. <br> <br> Some libraries such as python\'s `requests` can parse the header automatically and offer a convenient way of iterating through the results. For example: ```python def get_all_results(url):     while url:         r = requests.get(url)         r.raise_for_status()         for item in r.json()[\'results\']:           yield item         url = r.links.get(\'next\', {}).get(\'url\') ``` 
         * @summary Retrieve a list of frequencies of a word/words derived from a corpus.
         * @param {LexiStatsApiGetWordFrequenciesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWordFrequencies(requestParameters: LexiStatsApiGetWordFrequenciesRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StatsWordResultList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWordFrequencies(requestParameters.sourceLang, requestParameters.corpus, requestParameters.wordform, requestParameters.trueCase, requestParameters.lemma, requestParameters.lexicalCategory, requestParameters.grammaticalFeatures, requestParameters.sort, requestParameters.collate, requestParameters.minFrequency, requestParameters.maxFrequency, requestParameters.minNormalizedFrequency, requestParameters.maxNormalizedFrequency, requestParameters.offset, requestParameters.limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint provides the frequency of a given word. When multiple database records match the query parameters, the returned frequency is the sum of the individual frequencies. For example, if the query parameters are lemma=test, the returned frequency will include the verb \"test\", the noun \"test\" and the adjective \"test\" in all forms (Test, tested, testing, etc.) <br> <br> If you are interested in the frequency of the word \"test\" but want to exclude other forms (e.g., tested) use the option trueCase=test. Normally, the word \"test\" will be spelt with a capital letter at the beginning of a sentence. The option trueCase will ignore this and it will count \"Test\" and \"test\" as the same token. If you are interested in frequencies of \"Test\" and \"test\", use the option wordform=test or wordform=Test. Note that trueCase is not just a lower case of the word as some words are genuinely spelt with a capital letter such as the word \"press\" in Oxford University Press. <br> <br> Parameters can be provided in PATH, GET or POST (form or json). The parameters in PATH are overriden by parameters in GET, POST and json (in that order). In PATH, individual options are separated by semicolon and values are separated by commas (where multiple values can be used). Examples: * PATH: /lemma=test;lexicalCategory=noun * GET: /?lemma=test&lexicalCategory=noun * POST (json):    ```javascript     {       \"lemma\": \"test\",       \"lexicalCategory\": \"noun\"     }   ```  <br> One of the options wordform/trueCase/lemma/lexicalCategory has to be provided. 
         * @summary Retrieve the frequency of a word derived from a corpus.
         * @param {LexiStatsApiGetWordFrequencyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWordFrequency(requestParameters: LexiStatsApiGetWordFrequencyRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StatsWordResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWordFrequency(requestParameters.sourceLang, requestParameters.corpus, requestParameters.wordform, requestParameters.trueCase, requestParameters.lemma, requestParameters.lexicalCategory, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * LexiStatsApi - factory interface
 * @export
 */
export const LexiStatsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LexiStatsApiFp(configuration)
    return {
        /**
         * This endpoint returns frequencies of ngrams of size 1-4. That is the number of times a word (ngram size = 1) or words (ngram size > 1) appear in the corpus. Ngrams are case sensitive (\"I AM\" and \"I am\" will have different frequency) and frequencies are calculated per word (true case) so \"the book\" and \"the books\" are two different ngrams. The results can be filtered based on query parameters. <br> <br> Parameters can be provided in PATH, GET or POST (form or json). The parameters in PATH are overridden by parameters in GET, POST and json (in that order). In PATH, individual options are separated by semicolon and values are separated by commas (where multiple values can be used). <br> <br> Example for bigrams (ngram of size 2): * PATH: /tokens=a word,another word * GET: /?tokens=a word&tokens=another word * POST (json):    ```javascript     {         \"tokens\": [\"a word\", \"another word\"]     }   ```  Either \"tokens\" or \"contains\" has to be provided. <br> <br> Some queries with \"contains\" or \"sort\" can exceed the 30s timeout, in which case the API will return an error message with status code 503. You mitigate this by providing additional restrictions such as \"minFrequency\" and \"maxFrequency\". <br> <br> You can use the parameters \"offset\" and \"limit\" to paginate through large result sets. For convenience, the HTTP header \"Link\" is set on the response to provide links to \"first\", \"self\", \"next\", \"prev\" and \"last\" pages of results (depending on the context). For example, if the result set contains 50 results and the parameter \"limit\" is set to 25, the Links header will contain an URL for the first 25 results and the next 25 results. <br> <br> Some libraries such as python\'s `requests` can parse the header automatically and offer a convenient way of iterating through the results. For example: ```python def get_all_results(url):     while url:         r = requests.get(url)         r.raise_for_status()         for item in r.json()[\'results\']:           yield item         url = r.links.get(\'next\', {}).get(\'url\') ``` 
         * @summary Retrieve the frequency of ngrams (1-4) derived from a corpus
         * @param {LexiStatsApiGetNgramFrequenciesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNgramFrequencies(requestParameters: LexiStatsApiGetNgramFrequenciesRequest, options?: AxiosRequestConfig): AxiosPromise<NgramsResult> {
            return localVarFp.getNgramFrequencies(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint provides a list of frequencies for a given word or words. Unlike the /word/ endpoint, the results are split into the smallest units. <br> <br> To exclude a specific value, prepend it with the minus sign (\'-\'). For example, to get frequencies of the lemma \'happy\' but exclude superlative forms (i.e., happiest) you could use options \'lemma=happy;grammaticalFeatures=-degreeType:superlative\'. <br> <br> Parameters can be provided in PATH, GET or POST (form or json). The parameters in PATH are overridden by parameters in GET, POST and json (in that order). In PATH, individual options are separated by semicolon and values are separated by commas (where multiple values can be used). <br> <br> The parameters wordform/trueCase/lemma/lexicalCategory also exist in a plural form, taking a lists of items. Examples: * PATH: /wordforms=happy,happier,happiest * GET: /?wordforms=happy&wordforms=happier&wordforms=happiest * POST (json): ```javascript   {     \"wordforms\": [\"happy\", \"happier\", \"happiest\"]   } ``` A mor complex example of retrieving frequencies of multiple lemmas: ```   {       \"lemmas\": [\"happy\", \"content\", \"cheerful\", \"cheery\", \"merry\", \"joyful\", \"ecstatic\"],       \"grammaticalFeatures\": {           \"adjectiveFunctionType\": \"predicative\"       },       \"lexicalCategory\": \"adjective\",       \"sort\": [\"lemma\", \"-frequency\"]   } ``` Some queries with \"collate\" or \"sort\" can exceed the 30s timeout, in which case the API will return an error message with status code 503. You mitigate this by providing additional restrictions such as \"minFrequency\" and \"maxFrequency\". <br> <br> You can use the parameters \"offset\" and \"limit\" to paginate through large result sets. For convenience, the HTTP header \"Link\" is set on the response to provide links to \"first\", \"self\", \"next\", \"prev\" and \"last\" pages of results (depending on the context). For example, if the result set contains 50 results and the parameter \"limit\" is set to 25, the Links header will contain an URL for the first 25 results and the next 25 results. <br> <br> Some libraries such as python\'s `requests` can parse the header automatically and offer a convenient way of iterating through the results. For example: ```python def get_all_results(url):     while url:         r = requests.get(url)         r.raise_for_status()         for item in r.json()[\'results\']:           yield item         url = r.links.get(\'next\', {}).get(\'url\') ``` 
         * @summary Retrieve a list of frequencies of a word/words derived from a corpus.
         * @param {LexiStatsApiGetWordFrequenciesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWordFrequencies(requestParameters: LexiStatsApiGetWordFrequenciesRequest, options?: AxiosRequestConfig): AxiosPromise<StatsWordResultList> {
            return localVarFp.getWordFrequencies(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint provides the frequency of a given word. When multiple database records match the query parameters, the returned frequency is the sum of the individual frequencies. For example, if the query parameters are lemma=test, the returned frequency will include the verb \"test\", the noun \"test\" and the adjective \"test\" in all forms (Test, tested, testing, etc.) <br> <br> If you are interested in the frequency of the word \"test\" but want to exclude other forms (e.g., tested) use the option trueCase=test. Normally, the word \"test\" will be spelt with a capital letter at the beginning of a sentence. The option trueCase will ignore this and it will count \"Test\" and \"test\" as the same token. If you are interested in frequencies of \"Test\" and \"test\", use the option wordform=test or wordform=Test. Note that trueCase is not just a lower case of the word as some words are genuinely spelt with a capital letter such as the word \"press\" in Oxford University Press. <br> <br> Parameters can be provided in PATH, GET or POST (form or json). The parameters in PATH are overriden by parameters in GET, POST and json (in that order). In PATH, individual options are separated by semicolon and values are separated by commas (where multiple values can be used). Examples: * PATH: /lemma=test;lexicalCategory=noun * GET: /?lemma=test&lexicalCategory=noun * POST (json):    ```javascript     {       \"lemma\": \"test\",       \"lexicalCategory\": \"noun\"     }   ```  <br> One of the options wordform/trueCase/lemma/lexicalCategory has to be provided. 
         * @summary Retrieve the frequency of a word derived from a corpus.
         * @param {LexiStatsApiGetWordFrequencyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWordFrequency(requestParameters: LexiStatsApiGetWordFrequencyRequest, options?: AxiosRequestConfig): AxiosPromise<StatsWordResult> {
            return localVarFp.getWordFrequency(requestParameters, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getNgramFrequencies operation in LexiStatsApi.
 * @export
 * @interface LexiStatsApiGetNgramFrequenciesRequest
 */
export type LexiStatsApiGetNgramFrequenciesRequest = {
    
    /**
    * IANA language code
    * @type {string}
    * @memberof LexiStatsApiGetNgramFrequencies
    */
    readonly sourceLang: string
    
    /**
    * For corpora other than \'nmc\' (New Monitor Corpus) please contact api@oxforddictionaries.com
    * @type {string}
    * @memberof LexiStatsApiGetNgramFrequencies
    */
    readonly corpus: string
    
    /**
    * the size of ngrams requested (1-4)
    * @type {string}
    * @memberof LexiStatsApiGetNgramFrequencies
    */
    readonly ngramSize: string
    
    /**
    * List of tokens to filter. The tokens are separated by spaces, the list items are separated by comma (e.g., for bigrams (n=2) tokens=this is,this was, this will)
    * @type {string}
    * @memberof LexiStatsApiGetNgramFrequencies
    */
    readonly tokens?: string
    
    /**
    * Find ngrams containing the given token(s). Use comma or space as token separators; the order of tokens is irrelevant.
    * @type {string}
    * @memberof LexiStatsApiGetNgramFrequencies
    */
    readonly contains?: string
    
    /**
    * Flag specifying whether to lookup ngrams that include punctuation or not (possible values are \"true\" and \"false\"; default is \"false\")
    * @type {string}
    * @memberof LexiStatsApiGetNgramFrequencies
    */
    readonly punctuation?: string
    
    /**
    * Option specifying whether tokens should be returned as a single string (option \"google\") or as a list of strings (option \"oup\")
    * @type {string}
    * @memberof LexiStatsApiGetNgramFrequencies
    */
    readonly format?: string
    
    /**
    * Restrict the query to entries with frequency of at least `minFrequency`
    * @type {number}
    * @memberof LexiStatsApiGetNgramFrequencies
    */
    readonly minFrequency?: number
    
    /**
    * Restrict the query to entries with frequency of at most `maxFrequency`
    * @type {number}
    * @memberof LexiStatsApiGetNgramFrequencies
    */
    readonly maxFrequency?: number
    
    /**
    * Restrict the query to entries that appear in at least `minDocumentFrequency` documents
    * @type {number}
    * @memberof LexiStatsApiGetNgramFrequencies
    */
    readonly minDocumentFrequency?: number
    
    /**
    * Restrict the query to entries that appera in at most `maxDocumentFrequency` documents
    * @type {number}
    * @memberof LexiStatsApiGetNgramFrequencies
    */
    readonly maxDocumentFrequency?: number
    
    /**
    * collate the results by wordform, trueCase, lemma, lexicalCategory. Multiple values can be separated by commas (e.g., collate=trueCase,lemma,lexicalCategory).
    * @type {string}
    * @memberof LexiStatsApiGetNgramFrequencies
    */
    readonly collate?: string
    
    /**
    * sort the resulting list by wordform, trueCase, lemma, lexicalCategory, frequency, normalizedFrequency. Descending order is achieved by prepending the value with the minus sign (\'-\'). Multiple values can be separated by commas (e.g., sort=lexicalCategory,-frequency)
    * @type {string}
    * @memberof LexiStatsApiGetNgramFrequencies
    */
    readonly sort?: string
    
    /**
    * pagination - results offset
    * @type {number}
    * @memberof LexiStatsApiGetNgramFrequencies
    */
    readonly offset?: number
    
    /**
    * pagination - results limit
    * @type {number}
    * @memberof LexiStatsApiGetNgramFrequencies
    */
    readonly limit?: number
    
}

/**
 * Request parameters for getWordFrequencies operation in LexiStatsApi.
 * @export
 * @interface LexiStatsApiGetWordFrequenciesRequest
 */
export type LexiStatsApiGetWordFrequenciesRequest = {
    
    /**
    * IANA language code
    * @type {string}
    * @memberof LexiStatsApiGetWordFrequencies
    */
    readonly sourceLang: string
    
    /**
    * For corpora other than \'nmc\' (New Monitor Corpus) please contact api@oxforddictionaries.com
    * @type {string}
    * @memberof LexiStatsApiGetWordFrequencies
    */
    readonly corpus?: string
    
    /**
    * The written form of the word to look up (preserving case e.g., Book vs book)
    * @type {string}
    * @memberof LexiStatsApiGetWordFrequencies
    */
    readonly wordform?: string
    
    /**
    * The written form of the word to look up with normalised case (Books --> books)
    * @type {string}
    * @memberof LexiStatsApiGetWordFrequencies
    */
    readonly trueCase?: string
    
    /**
    * The lemma of the word to look up (e.g., Book, booked, books all have the lemma \"book\")
    * @type {string}
    * @memberof LexiStatsApiGetWordFrequencies
    */
    readonly lemma?: string
    
    /**
    * The lexical category of the word(s) to look up (e.g., adjective or noun)
    * @type {string}
    * @memberof LexiStatsApiGetWordFrequencies
    */
    readonly lexicalCategory?: string
    
    /**
    * The grammatical features of the word(s) to look up entered as a list of k:v (e.g., degree_type:comparative)
    * @type {string}
    * @memberof LexiStatsApiGetWordFrequencies
    */
    readonly grammaticalFeatures?: string
    
    /**
    * sort the resulting list by wordform, trueCase, lemma, lexicalCategory, frequency, normalizedFrequency. Descending order is achieved by prepending the value with the minus sign (\'-\'). Multiple values can be separated by commas (e.g., sort=lexicalCategory,-frequency)
    * @type {string}
    * @memberof LexiStatsApiGetWordFrequencies
    */
    readonly sort?: string
    
    /**
    * collate the results by wordform, trueCase, lemma, lexicalCategory. Multiple values can be separated by commas (e.g., collate=trueCase,lemma,lexicalCategory).
    * @type {string}
    * @memberof LexiStatsApiGetWordFrequencies
    */
    readonly collate?: string
    
    /**
    * Restrict the query to entries with frequency of at least `minFrequency`
    * @type {number}
    * @memberof LexiStatsApiGetWordFrequencies
    */
    readonly minFrequency?: number
    
    /**
    * Restrict the query to entries with frequency of at most `maxFrequency`
    * @type {number}
    * @memberof LexiStatsApiGetWordFrequencies
    */
    readonly maxFrequency?: number
    
    /**
    * Restrict the query to entries with frequency of at least `minNormalizedFrequency`
    * @type {number}
    * @memberof LexiStatsApiGetWordFrequencies
    */
    readonly minNormalizedFrequency?: number
    
    /**
    * Restrict the query to entries with frequency of at most `maxNormalizedFrequency`
    * @type {number}
    * @memberof LexiStatsApiGetWordFrequencies
    */
    readonly maxNormalizedFrequency?: number
    
    /**
    * pagination - results offset
    * @type {number}
    * @memberof LexiStatsApiGetWordFrequencies
    */
    readonly offset?: number
    
    /**
    * pagination - results limit
    * @type {number}
    * @memberof LexiStatsApiGetWordFrequencies
    */
    readonly limit?: number
    
}

/**
 * Request parameters for getWordFrequency operation in LexiStatsApi.
 * @export
 * @interface LexiStatsApiGetWordFrequencyRequest
 */
export type LexiStatsApiGetWordFrequencyRequest = {
    
    /**
    * IANA language code
    * @type {string}
    * @memberof LexiStatsApiGetWordFrequency
    */
    readonly sourceLang: string
    
    /**
    * For corpora other than \'nmc\' (New Monitor Corpus) please contact api@oxforddictionaries.com
    * @type {string}
    * @memberof LexiStatsApiGetWordFrequency
    */
    readonly corpus?: string
    
    /**
    * The written form of the word to look up (preserving case e.g., Books vs books)
    * @type {string}
    * @memberof LexiStatsApiGetWordFrequency
    */
    readonly wordform?: string
    
    /**
    * The written form of the word to look up with normalised case (Books --> books)
    * @type {string}
    * @memberof LexiStatsApiGetWordFrequency
    */
    readonly trueCase?: string
    
    /**
    * The lemma of the word to look up (e.g., Book, booked, books all have the lemma \"book\")
    * @type {string}
    * @memberof LexiStatsApiGetWordFrequency
    */
    readonly lemma?: string
    
    /**
    * The lexical category of the word(s) to look up (e.g., noun or verb)
    * @type {string}
    * @memberof LexiStatsApiGetWordFrequency
    */
    readonly lexicalCategory?: string
    
}

/**
 * LexiStatsApiGenerated - object-oriented interface
 * @export
 * @class LexiStatsApiGenerated
 * @extends {BaseAPI}
 */
export class LexiStatsApiGenerated extends BaseAPI {
    /**
     * This endpoint returns frequencies of ngrams of size 1-4. That is the number of times a word (ngram size = 1) or words (ngram size > 1) appear in the corpus. Ngrams are case sensitive (\"I AM\" and \"I am\" will have different frequency) and frequencies are calculated per word (true case) so \"the book\" and \"the books\" are two different ngrams. The results can be filtered based on query parameters. <br> <br> Parameters can be provided in PATH, GET or POST (form or json). The parameters in PATH are overridden by parameters in GET, POST and json (in that order). In PATH, individual options are separated by semicolon and values are separated by commas (where multiple values can be used). <br> <br> Example for bigrams (ngram of size 2): * PATH: /tokens=a word,another word * GET: /?tokens=a word&tokens=another word * POST (json):    ```javascript     {         \"tokens\": [\"a word\", \"another word\"]     }   ```  Either \"tokens\" or \"contains\" has to be provided. <br> <br> Some queries with \"contains\" or \"sort\" can exceed the 30s timeout, in which case the API will return an error message with status code 503. You mitigate this by providing additional restrictions such as \"minFrequency\" and \"maxFrequency\". <br> <br> You can use the parameters \"offset\" and \"limit\" to paginate through large result sets. For convenience, the HTTP header \"Link\" is set on the response to provide links to \"first\", \"self\", \"next\", \"prev\" and \"last\" pages of results (depending on the context). For example, if the result set contains 50 results and the parameter \"limit\" is set to 25, the Links header will contain an URL for the first 25 results and the next 25 results. <br> <br> Some libraries such as python\'s `requests` can parse the header automatically and offer a convenient way of iterating through the results. For example: ```python def get_all_results(url):     while url:         r = requests.get(url)         r.raise_for_status()         for item in r.json()[\'results\']:           yield item         url = r.links.get(\'next\', {}).get(\'url\') ``` 
     * @summary Retrieve the frequency of ngrams (1-4) derived from a corpus
     * @param {LexiStatsApiGetNgramFrequenciesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LexiStatsApiGenerated
     */
    public getNgramFrequencies(requestParameters: LexiStatsApiGetNgramFrequenciesRequest, options?: AxiosRequestConfig) {
        return LexiStatsApiFp(this.configuration).getNgramFrequencies(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint provides a list of frequencies for a given word or words. Unlike the /word/ endpoint, the results are split into the smallest units. <br> <br> To exclude a specific value, prepend it with the minus sign (\'-\'). For example, to get frequencies of the lemma \'happy\' but exclude superlative forms (i.e., happiest) you could use options \'lemma=happy;grammaticalFeatures=-degreeType:superlative\'. <br> <br> Parameters can be provided in PATH, GET or POST (form or json). The parameters in PATH are overridden by parameters in GET, POST and json (in that order). In PATH, individual options are separated by semicolon and values are separated by commas (where multiple values can be used). <br> <br> The parameters wordform/trueCase/lemma/lexicalCategory also exist in a plural form, taking a lists of items. Examples: * PATH: /wordforms=happy,happier,happiest * GET: /?wordforms=happy&wordforms=happier&wordforms=happiest * POST (json): ```javascript   {     \"wordforms\": [\"happy\", \"happier\", \"happiest\"]   } ``` A mor complex example of retrieving frequencies of multiple lemmas: ```   {       \"lemmas\": [\"happy\", \"content\", \"cheerful\", \"cheery\", \"merry\", \"joyful\", \"ecstatic\"],       \"grammaticalFeatures\": {           \"adjectiveFunctionType\": \"predicative\"       },       \"lexicalCategory\": \"adjective\",       \"sort\": [\"lemma\", \"-frequency\"]   } ``` Some queries with \"collate\" or \"sort\" can exceed the 30s timeout, in which case the API will return an error message with status code 503. You mitigate this by providing additional restrictions such as \"minFrequency\" and \"maxFrequency\". <br> <br> You can use the parameters \"offset\" and \"limit\" to paginate through large result sets. For convenience, the HTTP header \"Link\" is set on the response to provide links to \"first\", \"self\", \"next\", \"prev\" and \"last\" pages of results (depending on the context). For example, if the result set contains 50 results and the parameter \"limit\" is set to 25, the Links header will contain an URL for the first 25 results and the next 25 results. <br> <br> Some libraries such as python\'s `requests` can parse the header automatically and offer a convenient way of iterating through the results. For example: ```python def get_all_results(url):     while url:         r = requests.get(url)         r.raise_for_status()         for item in r.json()[\'results\']:           yield item         url = r.links.get(\'next\', {}).get(\'url\') ``` 
     * @summary Retrieve a list of frequencies of a word/words derived from a corpus.
     * @param {LexiStatsApiGetWordFrequenciesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LexiStatsApiGenerated
     */
    public getWordFrequencies(requestParameters: LexiStatsApiGetWordFrequenciesRequest, options?: AxiosRequestConfig) {
        return LexiStatsApiFp(this.configuration).getWordFrequencies(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint provides the frequency of a given word. When multiple database records match the query parameters, the returned frequency is the sum of the individual frequencies. For example, if the query parameters are lemma=test, the returned frequency will include the verb \"test\", the noun \"test\" and the adjective \"test\" in all forms (Test, tested, testing, etc.) <br> <br> If you are interested in the frequency of the word \"test\" but want to exclude other forms (e.g., tested) use the option trueCase=test. Normally, the word \"test\" will be spelt with a capital letter at the beginning of a sentence. The option trueCase will ignore this and it will count \"Test\" and \"test\" as the same token. If you are interested in frequencies of \"Test\" and \"test\", use the option wordform=test or wordform=Test. Note that trueCase is not just a lower case of the word as some words are genuinely spelt with a capital letter such as the word \"press\" in Oxford University Press. <br> <br> Parameters can be provided in PATH, GET or POST (form or json). The parameters in PATH are overriden by parameters in GET, POST and json (in that order). In PATH, individual options are separated by semicolon and values are separated by commas (where multiple values can be used). Examples: * PATH: /lemma=test;lexicalCategory=noun * GET: /?lemma=test&lexicalCategory=noun * POST (json):    ```javascript     {       \"lemma\": \"test\",       \"lexicalCategory\": \"noun\"     }   ```  <br> One of the options wordform/trueCase/lemma/lexicalCategory has to be provided. 
     * @summary Retrieve the frequency of a word derived from a corpus.
     * @param {LexiStatsApiGetWordFrequencyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LexiStatsApiGenerated
     */
    public getWordFrequency(requestParameters: LexiStatsApiGetWordFrequencyRequest, options?: AxiosRequestConfig) {
        return LexiStatsApiFp(this.configuration).getWordFrequency(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }
}
